import * as path from "path";
import esbuild from "esbuild";
import { isCSSRequest } from "../core/render/util.js";
import {
  getPageDatasByChunk,
  getPageDataByViteID,
  hasPageDataByViteID,
  getPageDatasByClientOnlyChunk
} from "../core/build/internal.js";
const PLUGIN_NAME = "@astrojs/rollup-plugin-build-css";
const ASTRO_STYLE_PREFIX = "@astro-inline-style";
const ASTRO_PAGE_STYLE_PREFIX = "@astro-page-all-styles";
function isStyleVirtualModule(id) {
  return id.startsWith(ASTRO_STYLE_PREFIX);
}
function isPageStyleVirtualModule(id) {
  return id.startsWith(ASTRO_PAGE_STYLE_PREFIX);
}
function isRawOrUrlModule(id) {
  return id.match(/(\?|\&)([^=]+)(raw|url)/gm);
}
function rollupPluginAstroBuildCSS(options) {
  const { internals } = options;
  const styleSourceMap = /* @__PURE__ */ new Map();
  function* walkStyles(ctx, id, seen = /* @__PURE__ */ new Set()) {
    seen.add(id);
    if (styleSourceMap.has(id)) {
      yield [id, styleSourceMap.get(id)];
    }
    const info = ctx.getModuleInfo(id);
    if (info) {
      for (const importedId of [...info.importedIds, ...info.dynamicallyImportedIds]) {
        if (!seen.has(importedId) && !isRawOrUrlModule(importedId)) {
          yield* walkStyles(ctx, importedId, seen);
        }
      }
    }
  }
  async function addStyles() {
    var _a;
    for (const id of this.getModuleIds()) {
      if (hasPageDataByViteID(internals, id)) {
        let pageStyles = "";
        for (const [_styleId, styles] of walkStyles(this, id)) {
          pageStyles += styles;
        }
        if (!pageStyles)
          continue;
        const { code: minifiedCSS } = await esbuild.transform(pageStyles, {
          loader: "css",
          minify: true
        });
        const referenceId = this.emitFile({
          name: "entry.css",
          type: "asset",
          source: minifiedCSS
        });
        const fileName = this.getFileName(referenceId);
        (_a = getPageDataByViteID(internals, id)) == null ? void 0 : _a.css.add(fileName);
      }
    }
  }
  return {
    name: PLUGIN_NAME,
    configResolved(resolvedConfig) {
      const plugins = resolvedConfig.plugins;
      const viteCSSPostIndex = resolvedConfig.plugins.findIndex((p) => p.name === "vite:css-post");
      if (viteCSSPostIndex !== -1) {
        const viteCSSPost = plugins[viteCSSPostIndex];
        delete viteCSSPost.renderChunk;
        delete viteCSSPost.generateBundle;
        const ourIndex = plugins.findIndex((p) => p.name === PLUGIN_NAME);
        const ourPlugin = plugins[ourIndex];
        plugins.splice(ourIndex, 1);
        plugins.splice(viteCSSPostIndex - 1, 0, ourPlugin);
      }
    },
    async resolveId(id) {
      if (isPageStyleVirtualModule(id)) {
        return id;
      }
      if (isStyleVirtualModule(id)) {
        return id;
      }
      return void 0;
    },
    async transform(value, id) {
      if (isStyleVirtualModule(id)) {
        styleSourceMap.set(id, value);
      }
      if (isCSSRequest(id)) {
        styleSourceMap.set(id, value);
      }
      return null;
    },
    async renderChunk(_code, chunk) {
      if (options.target === "server")
        return null;
      let chunkCSS = "";
      let isPureCSS = true;
      for (const [id] of Object.entries(chunk.modules)) {
        if (!isCSSRequest(id) && !isPageStyleVirtualModule(id)) {
          isPureCSS = false;
        }
        if (styleSourceMap.has(id)) {
          chunkCSS += styleSourceMap.get(id);
        }
      }
      if (!chunkCSS)
        return null;
      if (isPureCSS) {
        internals.pureCSSChunks.add(chunk);
      }
      const { code: minifiedCSS } = await esbuild.transform(chunkCSS, {
        loader: "css",
        minify: true
      });
      const referenceId = this.emitFile({
        name: chunk.name + ".css",
        type: "asset",
        source: minifiedCSS
      });
      if (chunk.type === "chunk") {
        const fileName = this.getFileName(referenceId);
        for (const pageData of getPageDatasByChunk(internals, chunk)) {
          pageData.css.add(fileName);
        }
        for (const pageData of getPageDatasByClientOnlyChunk(internals, chunk)) {
          pageData.css.add(fileName);
        }
      }
      return null;
    },
    async generateBundle(opts, bundle) {
      const hasPureCSSChunks = internals.pureCSSChunks.size;
      const pureChunkFilenames = new Set([...internals.pureCSSChunks].map((chunk) => chunk.fileName));
      const emptyChunkFiles = [...pureChunkFilenames].map((file) => path.basename(file)).join("|").replace(/\./g, "\\.");
      const emptyChunkRE = new RegExp(opts.format === "es" ? `\\bimport\\s*"[^"]*(?:${emptyChunkFiles})";
?` : `\\brequire\\(\\s*"[^"]*(?:${emptyChunkFiles})"\\);
?`, "g");
      await addStyles.call(this);
      for (const [chunkId, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk") {
          if (hasPureCSSChunks) {
            if (internals.pureCSSChunks.has(chunk) && !chunk.exports.length) {
              delete bundle[chunkId];
            } else {
              chunk.code = chunk.code.replace(emptyChunkRE, (m) => `/* empty css ${"".padEnd(m.length - 15)}*/`);
            }
          }
        }
      }
    }
  };
}
export {
  rollupPluginAstroBuildCSS
};
